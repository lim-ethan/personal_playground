# Milvus를 이용한 벡터 검색 시스템 구현

---

## 사용 이유 및 목적

- 기존에 고려하였던 ElasticSearch는 2048차원까지 무료 지원, 4096 이하 차원 데이터는 유료 전환 필요 (수정)  
- Elasticsearch 8.x 버전은 4096차원 지원 표기, 실제 도커 환경 테스트 시 2048까지만 지원  
- Upstage Embedding Large 모델은 4096차원 벡터를 지원  
- 따라서 4096차원 벡터 검색이 가능한 OSS 기반 DB 중 성능 및 구현 측면에서 Milvus 선택  

---

## 주요 내용

- Milvus를 이용한 Vector Search DB 구현  
- Upstage Solar-Pro Model API 연동  

---

## 코드 설명

### 1. Milvus 연결 및 스키마 정의

- Milvus 연결: `connections.connect`를 통해 Milvus 데이터베이스에 연결

```python
connections.connect(alias="default", host="localhost", port="19530")
```

- Collection 스키마 정의

FieldSchema로 각 필드의 데이터 유형과 속성 정의

- 필수 필드:

id: 기본 키, INT64 타입 (필수)

vector: 벡터 데이터, FLOAT_VECTOR 타입, 차원 4096 (필수)

기타 문자열 필드 (title, main_text, page, file_path)는 텍스트 정보 저장 (옵션)



```python
fields = [
    FieldSchema(name="id", dtype=DataType.INT64, is_primary=True, auto_id=True),
    FieldSchema(name="title", dtype=DataType.VARCHAR, max_length=255),
    FieldSchema(name="main_text", dtype=DataType.VARCHAR, max_length=16384),
    FieldSchema(name="page", dtype=DataType.VARCHAR, max_length=20),
    FieldSchema(name="file_path", dtype=DataType.VARCHAR, max_length=255),
    FieldSchema(name="vector", dtype=DataType.FLOAT_VECTOR, dim=4096)
]
schema = CollectionSchema(fields, "capacity_schema")
collection = Collection(name="splunk_menual_v5", schema=schema)
```

### 2. 인덱스 생성
- 벡터 필드 인덱스 설정:
IVF_FLAT 인덱스 유형을 사용하여 검색 효율성을 향상
코사인 유사도(COSINE)를 기준으로 검색
nlist 파라미터를 설정하여 벡터 클러스터링 수행

```python
index_params = {
    "index_type": "IVF_FLAT",
    "metric_type": "COSINE",
    "params": {"nlist": 256}
}
collection.create_index(field_name="vector", index_params=index_params)
```

### 3. 데이터 삽입
- ./embedding_result 폴더의 JSON 파일에서 데이터를 읽고 Milvus에 삽입
JSON 파일에서 vector 필드를 읽어 vector 필드로 변환

```python
root = './embedding_result'
files = os.listdir(root)

for file in files:
    json_path = f'{root}/{file}'
    with open(json_path, 'r', encoding='utf-8-sig') as f:
        tmp = json.load(f)
    tmp['vector'] = tmp['vector']
    if "vector" in tmp:
        del tmp["vector"]
    collection.insert(tmp)
    print('ㅁ INSERT DATA : ', tmp['title'])
```

- JSON 원본 파일 내용

```python
{
    "title": "Splunk-9.1.0-Capacity_ko-KR",
    "main_text": "<h1 id='0' style='font-size:14px'>Splunk® Enterprise 9.1.0<br>용량 계획 매뉴얼<br>생성일: 2023-06-28 오후 6:06</h1>",
    "page": "1",
    "file_path": "../DOCUMENT_PARS_RESULT/Splunk-9.1.0-Capacity_ko-KR/page_1.json",
    "vector": [
        -0.007793426513671875,
        -0.0021762847900390625,
        -0.0299835205078125,
        -0.0168304443359375,
      .
      .
      .
      ] #"vector" 컬럼은 Ustage Embedding Large 모델의 경우, 4096 Dimension으로 Return
}
```

### 4. OpenAI API를 이용한 쿼리 벡터 생성
- Upstage의 임베딩 API를 사용하여 사용자 입력 쿼리(query)를 벡터로 변환

```python
query = "단일 인스턴스의 최소 사양은"
query_vector = client.embeddings.create(
    model="embedding-query",
    input=query
).data[0].embedding
```


### 5. Milvus에서 벡터 검색
- 변환된 쿼리 벡터를 Milvus에서 검색하여 유사도가 높은 상위 3개의 결과를 반환합니다.
검색 결과는 필요한 필드(id, title, main_text, page, file_path, vector)와 함께 반환.

```python
search_params = {
    "index_type": "IVF_FLAT",
    "metric_type": "COSINE",
    "params": {"nlist": 256}
}

results = collection.search(
    [query_vector],
    "vector",
    search_params,
    limit=3,
    output_fields=["id", "title", "main_text", "page", "file_path", "vector"]
)
```

### 6. 검색 결과 처리
- 검색된 결과 중 첫 번째 문서의 본문 텍스트를 추출하여 retrival_docs 변수에 저장.
```python
retrival_docs = results[0][0].to_dict()['entity']['main_text']
```

### 7. 실행 과정 요약
- Milvus와 연결하고 데이터 스키마를 정의.
- 인덱스를 생성하여 검색 성능 최적화.
- JSON 파일을 읽어 Milvus 컬렉션에 데이터 삽입.
- Upstage API를 이용해 사용자의 쿼리를 벡터로 변환.
- Milvus에서 유사도를 계산하여 검색 결과 반환.
- 결과 데이터를 처리하여 최종적으로 유사한 문서의 본문 반환.

### 8. 진행 예정 사항
- Milvus DB의 구성요소 파악 (etcd, minio, standalone)
- search parameter, index parameter 요소 파악 (index_type, metric_type, params)
- 적재된 DB data update 방법 파악 (upsert 로직 구현 및 테스트 진행 예정)